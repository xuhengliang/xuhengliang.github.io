<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.8.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo.jpg">
	<link rel="shortcut icon" href="/img/logo.jpg">
	
			    <title>
    Java学习之路
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    <meta name="keywords" content="miccall">
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/timg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
</head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/miccall" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url();background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2></h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>[TOC]</p>
<h1 id="基础语法与算法"><a href="#基础语法与算法" class="headerlink" title="基础语法与算法"></a>基础语法与算法</h1><h2 id="a-与-a的区别？"><a href="#a-与-a的区别？" class="headerlink" title="a++ 与 ++a的区别？"></a>a++ 与 ++a的区别？</h2><p>   a++: 后置自增,先计算表达式的值,变量值后+1<br>   ++a: 前置自增,变量值先+1,再计算表达式的值</p>
<h2 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h2><p>&amp;有两个用法：  </p>
<ul>
<li>第一个是作为逻辑运算符使用，被当成逻辑运算符时有一个非短路的特性，即当第一个操作数为false，那么第二个操作数仍然执行。</li>
<li>第二个是作为位运算符使用。  </li>
</ul>
<p>&amp;&amp;只有一个用法：</p>
<ul>
<li>只能作为逻辑运算符使用，和&amp;的区别在于&amp;&amp;有一个短路的特点，即当第一个操作数为false时（因为这个时候已经可以确定表达式的最终结果已经是false），那么第二个操作数不会执行。</li>
</ul>
<h2 id="说说jvm"><a href="#说说jvm" class="headerlink" title="***说说jvm"></a>***说说jvm</h2><p>jvm: java虚拟机,<br>用法1:可以将字节码解释成不同平台都能识别的指令<br>用法2:在jvm中的垃圾回收机制,可以自动回收系统中的无用内存</p>
<h2 id="GC是什么-为什么要有GC"><a href="#GC是什么-为什么要有GC" class="headerlink" title="***GC是什么? 为什么要有GC?"></a>***GC是什么? 为什么要有GC?</h2><p>   GC为垃圾回收器,系统中开辟了大量空间,当这些空间无用时,可通过GC进行释放;提高系统执行性能</p>
<h2 id="数组有没有length-这个方法-String有没有length-这个方法"><a href="#数组有没有length-这个方法-String有没有length-这个方法" class="headerlink" title="数组有没有length()这个方法?String有没有length()这个方法?"></a>数组有没有length()这个方法?String有没有length()这个方法?</h2><p>   数组没有length()方法，只有length属性;<br>   String有length()方法;</p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="什么是多态？"><a href="#什么是多态？" class="headerlink" title="什么是多态？"></a>什么是多态？</h2><p>   概念：多态是面向对象的基本特征之一。在java中一个对象的类型可以分为两种，即编译时类型与运行时类型。当一个对象的编译时类型和运行时类型不相同的时候，就发生了所谓的多态。</p>
<p>   理解：换句话说，在Java中用一个父类（父接口）的变量指向之类的对象时，就发生了多态。比如 A a = new B()， 其中A是B的父类或者父接口。为什么会有这样的特性？为什么不是子类的变量指向父类的对象？我们可以换一个生活中的例子来理解。比如现在想要一个动物，先声明一个动物的变量：<br>   Animal a;<br>   但是在实际生活中，根本没有一个具体的物种叫动物，所以其实我们需要创建的一个具体的动物的对象，比如狗(动物是狗的父类)：<br>   new Dog();<br>   最后将一条狗给与正需要一个动物的‘你’是一个非常合理的行为：<br>   Animal a = new Dog();<br>   反过来却不成立，同样也不合理，你没办法把随便一个动物给一个正需要狗的人。</p>
<p>   作用：多态在面向对象编程中有着非常重要的作用。很多架构搭建，设计模式都使用到了多态的特性。多态的最大作用在于，使用一个父类的变量调用方法时，本质上调用的是子类的重写方法。换而言之，让一个Animal a执行 ‘叫喊’的行为，本质上我们听到的应该是“旺、旺、旺”，因为这个动物其实是Dog。这个特点让多态广泛的运用在架构与程序设计之中，极大的增强了程序的拓展性与维护性。</p>
<h2 id="Integer封装类可以被继承吗？"><a href="#Integer封装类可以被继承吗？" class="headerlink" title="Integer封装类可以被继承吗？"></a>Integer封装类可以被继承吗？</h2><p>   不能,因为它是final修饰的类。<br>   sun在设计Integer类时添加了final关键字，意为不让其他人随意的拓展和覆盖Integer本来的行为方法。这么设计的作用在于Integer是int类型的包装类，是对基本类型在面向对象的一个补充，很多基础类和第三方的工具类大量引用了这个类型的变量。如果随意覆盖本来的方法会导致这些基础类无法达到预想的结果，从而破坏了底层的实现效果（比如破坏了自动装箱和自动拆箱）。这是sun公司不愿意看到的。如果要对Integer有任何拓展，完全可以通过自定义一个类对Integer进行封装来实现，无需继承。</p>
<h2 id="String可以被继承吗？"><a href="#String可以被继承吗？" class="headerlink" title="String可以被继承吗？"></a>String可以被继承吗？</h2><p>   不能,同上</p>
<h2 id="int-和-Integer有什么区别？"><a href="#int-和-Integer有什么区别？" class="headerlink" title="int 和 Integer有什么区别？"></a>int 和 Integer有什么区别？</h2><p>   int为基本类型,Integer为引用类型。<br>   Integer是int类型的包装类，对于int类型在面向对象中的补充。在很多时候没办法直接使用int基本类型，这个时候就需要用到Integer了，比如泛型时，是不能填写基本类型的，必须使用包装类。另外在很多实体类的设计时，通常也是使用包装类，因为包装类可以直接复制为null，而基本类型必须根据不同的基本类型赋予不同的值，操作起来会更加麻烦。</p>
<h2 id="extends和implements区别"><a href="#extends和implements区别" class="headerlink" title="extends和implements区别"></a>extends和implements区别</h2><p>  implements: 用于实现一个接口<br>  extends:  用于继承一个类<br>  注意：当一个接口需要继承另一个接口时，需要用到extends关键字，而且接口继承多个接口。</p>
<h2 id="构造器Constructor是否可被override"><a href="#构造器Constructor是否可被override" class="headerlink" title="构造器Constructor是否可被override?"></a>构造器Constructor是否可被override?</h2><p>   构造器Constructor不能被继承，因此不能重写，但可以被重载。</p>
<h2 id="接口是否可以继承接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete-class）？抽象类中是否可以有静态的main方法？"><a href="#接口是否可以继承接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete-class）？抽象类中是否可以有静态的main方法？" class="headerlink" title="接口是否可以继承接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？抽象类中是否可以有静态的main方法？"></a>接口是否可以继承接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？抽象类中是否可以有静态的main方法？</h2><ol>
<li>接口可以继承接口，而且接口继承多个接口</li>
<li>抽象类可以实现接口</li>
<li>抽象类可以继承具体类</li>
<li>抽象类中可以有静态main方法</li>
</ol>
<h2 id="类的加载机制"><a href="#类的加载机制" class="headerlink" title="类的加载机制"></a>类的加载机制</h2><ul>
<li>什么是类加载机制？<br>在一个java程序运行时，虚拟机并不会立刻将这个程序所有的类信息加载到内存中，而是在这个类第一次被使用时进行加载。将一个类加载到虚拟机内存中的过程称为类加载机制。<br>注意：一个类在一条JVM进程中只会被加载一次。</li>
<li><p>类加载的步骤<br>类加载可以大致分成3个步骤，分别是：  </p>
<ul>
<li>加载阶段<br>在加载阶段需要用到类加载器（ClassLoader类），虚拟机需要完成以下3件事情：<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明一定要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等，不同的渠道可以使用不同的类加载器）;</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li>
<li>在堆内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；</li>
</ul>
</li>
<li>连接阶段<br>连接阶段和加载阶段是交叉进行的，可能加载阶段还没有完成，连接阶段已经开始，但是加载和连接的开始顺序是固定不变的。连接阶段又可以拆分成3个阶段：<ul>
<li>验证：验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</li>
<li>准备：准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值</li>
<li>解析：<br>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</li>
</ul>
</li>
<li><p>初始化阶段<br>  在类的初始化阶段，JVM负责对类进行初始化，主要是对静态Field初始化。<br>  对静态Field初始化分两种：  </p>
<ul>
<li>声明静态Field时指定初始值；  </li>
<li>使用静态初始化块为静态Field指定初始值；  </li>
</ul>
<p>初始化顺序会按照源码的编写顺序执行。</p>
</li>
<li>类的加载的时机<br>当碰到以下几种情况时会触发一个类被加载进虚拟机内存中：</li>
<li>创建类的实例。（new关键字、反射、反序列化等等）</li>
<li>访问类中的某个静态成员</li>
<li>使用反射方式强制创建某个类对应的Class对象。比如：Class.forName(“包名.类名”);</li>
<li>加载某个类的子类</li>
<li>直接使用java.exe命令运行某个主类，当运行某个主类时，程序会先加载该主类</li>
</ul>
</li>
</ul>
<h2 id="（类加载机制）据下方代码，写出打印结果："><a href="#（类加载机制）据下方代码，写出打印结果：" class="headerlink" title="（类加载机制）据下方代码，写出打印结果："></a>（类加载机制）据下方代码，写出打印结果：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class SSClass</span><br><span class="line">&#123;</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;SSClass&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line">public class SuperClass extends SSClass</span><br><span class="line">&#123;</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;SuperClass init!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static int value = 123;</span><br><span class="line"> </span><br><span class="line">    public SuperClass()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;init SuperClass&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class SubClass extends SuperClass</span><br><span class="line">&#123;</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;SubClass init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    static int a;</span><br><span class="line"> </span><br><span class="line">    public SubClass()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;init SubClass&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class NotInitialization</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br>SSClass<br>SuperClass init!<br>123</p>
<p>原因：<br>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p>
<h2 id="（类加载机制）查看如下代码，写出打印结果："><a href="#（类加载机制）查看如下代码，写出打印结果：" class="headerlink" title="（类加载机制）查看如下代码，写出打印结果："></a>（类加载机制）查看如下代码，写出打印结果：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package jvm.classload;</span><br><span class="line"> </span><br><span class="line">public class StaticTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        staticFunction();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    static StaticTest st = new StaticTest();</span><br><span class="line"> </span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    StaticTest()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;3&quot;);</span><br><span class="line">        System.out.println(&quot;a=&quot;+a+&quot;,b=&quot;+b);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void staticFunction()&#123;</span><br><span class="line">        System.out.println(&quot;4&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    int a=110;</span><br><span class="line">    static int b =112;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：<br>2<br>3<br>a=110,b=0<br>1<br>4  </p>
</blockquote>
<h2 id="请简述面向对象的一些基本概念"><a href="#请简述面向对象的一些基本概念" class="headerlink" title="请简述面向对象的一些基本概念"></a>请简述面向对象的一些基本概念</h2><ol>
<li>封装:将类的属性私有化,使用方法进行封装来获取设置和获取属性值</li>
<li>继承:子类继承父类,可使用父类的属性和方法; 另一大特性:重写</li>
<li>多态:父类对象指向子类对象,可以调用子类重写方法</li>
<li>抽象:如果一个类有相关方法不知具体实现,该方法可设置为抽象方法,所在类就是抽象类;<pre><code>具体实现交给子类完成;在应用中抽象类可作为模板使用
</code></pre></li>
</ol>
<h2 id="java中的常用类，不少于6个？"><a href="#java中的常用类，不少于6个？" class="headerlink" title="java中的常用类，不少于6个？"></a>java中的常用类，不少于6个？</h2><p>  String,StringBuffer,Date,SimpleDateFormat,Random,Math,System,Runtime等</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="List-Set-Map是否继承自Collection接口"><a href="#List-Set-Map是否继承自Collection接口" class="headerlink" title="List, Set, Map是否继承自Collection接口?"></a>List, Set, Map是否继承自Collection接口?</h2><p>  List，Set是，Map不是 </p>
<h2 id="HashMap的数据结构-存放数据的机制和扩容问题"><a href="#HashMap的数据结构-存放数据的机制和扩容问题" class="headerlink" title="HashMap的数据结构  存放数据的机制和扩容问题"></a>HashMap的数据结构  存放数据的机制和扩容问题</h2><p>  HashMap底层采用的是哈希表这种数据结构。<br>  哈希表的特点在于查询速度快，时间复杂度为O(1)。  </p>
<ul>
<li>存放数据的机制：<br>哈希表实际上是一个数组，当一个键值对(key-value)要放入HashMap中时，首先会获得这个键(key)的hashcode，通过hashcode结合一个哈希函数计算得到一个int类型的值。这个值会充当数组的下标，将该键值对放入数组指定的下标位置。如果该位置已经存在一个键值对数据，则会进行键的对比，如果两个键通过equals方法比较返回true，则hashmap会认为key重复，则直接做一个value覆盖的操作。如果不重复，则会在数组这个位置形成一个链表将两个元素链接起来。这是采用的链地址法解决冲突的一种手段。</li>
<li>扩容问题：<br>哈希表有一个填充因子，填充因子是元素个数与数组长度的占比。当元素个数与数组长度的比例达到填充因子的大小时，则需要进行扩容。扩容就是创建一个更大的数组，将老的数组的元素通过哈希函数的计算重新放入新的数组中，从而降低元素越来越多所带来的哈希表查询性能严重下降的问题。但是扩容本身就是一个非常耗时的操作，所以在预先知道数据量很大的情况下，在创建HashMap的时候应该提前设置好底层哈希表的总长度和填充因子的大小，尽可能避免在元素添加过程中频繁的触发扩容机制。</li>
</ul>
<h2 id="谈谈HashSet的存储原理"><a href="#谈谈HashSet的存储原理" class="headerlink" title="谈谈HashSet的存储原理"></a>谈谈HashSet的存储原理</h2><p>   HashSet的底层就是由HashMap实现的，所以具体存储原理可以参照HashMap的底层实现。</p>
<h2 id="list和map的应用场景"><a href="#list和map的应用场景" class="headerlink" title="list和map的应用场景"></a>list和map的应用场景</h2><p>  list: 存储有序且允许重复的单个对象<br>  map: 存储无序且唯一的键值对</p>
<h2 id="常用集合的的底层实现？"><a href="#常用集合的的底层实现？" class="headerlink" title="常用集合的的底层实现？"></a>常用集合的的底层实现？</h2><ul>
<li>ArrayList和Vector:<br>ArrayList和Vector是List的两个典型实现类。它们底层的实现方案相同。都是采用动态数组的方式实现的。特点是元素有序并且可以重复。ArrayList本身是线程不安全的，Vector是线程安全的。但是Vector比较古老，所以绝大多数情况下应该使用ArrayList。</li>
<li>LinkedList:<br>LinkedList也是List的一个具有代表性的实现类。底层采用的是双向链表。从中间插入和删除元素的效率更高。</li>
<li>HashMap:<br>HashMap的是Map集合的常用实现类，底层采用的是哈希表的数据结构存放数据的。特点是插入和查询速度很快。但是随着元素个数越来越多，效率会有所下降，但是仍然是效率很高的一种数据结构。HashMap的key值是无序且不重复的。</li>
<li>LinkedHashMap:<br>LinkedHashMap底层采用的是哈希表 + 链表的形式存放数据的。因为需要额外的维护一个链表，所谓元素的操作速度会比HashMap略慢。但是因为有链表的存在，遍历元素的速度反而会比HashMap快，并且可以按照元素的插入顺序遍历出来。</li>
<li>TreeMap:<br>底层采用的是红-黑树实现的。相对于哈希表，红黑树的插入和查询速度要慢，但是红-黑树可以维护元素本身的字典顺序，所以当需要对key进行大小排序的时候，才应该使用TreeMap，否则都应该选择HashMap</li>
<li>HashSet/LinkedHashSet/TreeSet:<br>Set集合的底层其实就是Map集合实现的。Set集合中包含一个Map集合，每个元素插入到Set集合中时，其实就是插入到底层的Map集合的key的位置，value是一个固定的Object对象，没有任何意义。因此可以发现Set和Map的实现类几乎是一一对应的。</li>
</ul>
<h2 id="Map怎么实现有序"><a href="#Map怎么实现有序" class="headerlink" title="Map怎么实现有序"></a>Map怎么实现有序</h2><p>  通过LinkedHashMap实现有序，具体实现同上</p>
<h2 id="Set和Map的底层"><a href="#Set和Map的底层" class="headerlink" title="Set和Map的底层"></a>Set和Map的底层</h2><p>  Set底层实现是由Map完成的</p>
<h2 id="hashmap和hashtable的区别？"><a href="#hashmap和hashtable的区别？" class="headerlink" title="hashmap和hashtable的区别？"></a>hashmap和hashtable的区别？</h2><p>  Hashtable：<br>    线程安全，效率会低于HashMap。而且key和value都不能存放null值。<br>  HashMap：<br>    线程不安全，因此效率会高于Hashtable。key和value都可以为null，但是key只能有一个null。</p>
<h2 id="Collections-vs-Collection"><a href="#Collections-vs-Collection" class="headerlink" title="Collections vs Collection"></a>Collections vs Collection</h2><p>  Collections: 集合的工具类<br>  Collection: 用于存储单个对象的集合接口</p>
<h2 id="List-vs-Set"><a href="#List-vs-Set" class="headerlink" title="List vs Set"></a>List vs Set</h2><p>  List: 存储有序且允许重复的对象,可以使用下标遍历<br>  Set:  存储无序且唯一的对象,不能使用下标遍历</p>
<h2 id="集合的工具类有哪些？如何实现集合排序？不使用工具类的话怎么排序？"><a href="#集合的工具类有哪些？如何实现集合排序？不使用工具类的话怎么排序？" class="headerlink" title="集合的工具类有哪些？如何实现集合排序？不使用工具类的话怎么排序？"></a>集合的工具类有哪些？如何实现集合排序？不使用工具类的话怎么排序？</h2><p>  集合的工具类: Arrays,Collections<br>  工具类排序:   Arrays.sort(),Collections.sort()<br>  如果不使用工具类，对于Map和Set可以分别采用TreeMap和TreeSet实现元素的排序。对于List，则可以手写一个排序算法实现元素的排序，比如快速排序、希尔排序等</p>
<h2 id="ArrayList-vs-LinkedList"><a href="#ArrayList-vs-LinkedList" class="headerlink" title="ArrayList vs LinkedList"></a>ArrayList vs LinkedList</h2><p>  ArrayList: 通过数组扩容的方式存储对象,查找和向后追加元素效率高<br>  LinkedList:通过双向链表的方式存储对象,连续位置添加和删除效率高</p>
<h2 id="Set-vs-Map"><a href="#Set-vs-Map" class="headerlink" title="Set vs Map"></a>Set vs Map</h2><p>  联系: Set的存储是通过Map来实现的<br>  区别: Set存储单个对象无序且唯一, Map存储键值对(key-value),key无序且唯一  </p>
<h2 id="ConcurrentHashMap-vs-HashMap-vs-LinkedHashMap"><a href="#ConcurrentHashMap-vs-HashMap-vs-LinkedHashMap" class="headerlink" title="ConcurrentHashMap vs HashMap vs LinkedHashMap"></a>ConcurrentHashMap vs HashMap vs LinkedHashMap</h2><ul>
<li>HashMap：<br>查询和插入速度极快，但是线程不安全，在多线程情况下在扩容的情况下可能会形成闭环链路，耗光cpu资源。</li>
<li>LinkedHashMap：<br>基本和HashMap实现类似，多了一个链表来维护元素插入的顺序，因此维护的效率会比HashMap略低。但是因为有链表的存在，遍历效率会高于HashMap。</li>
<li>ConcurrentHashMap：<br>线程安全，而且采用分段锁的方式进行数据同步，因此相对于Hashtable来说，效率要高。但是因为引入了段的概念，所以每次元素插入或者获取，需要进行两次哈希算法，第一次确定到该元素位于哪一段，第二次才能真正确定到元素位置。因此效率会低于HashMap。不过在多线程情况下，这种性能的牺牲换取数据安全是非常值得的。因此在多线程的情况下应该首选ConcurrentHashMap。</li>
</ul>
<h1 id="IO流与异常"><a href="#IO流与异常" class="headerlink" title="IO流与异常"></a>IO流与异常</h1><h2 id="运行时的异常和一般异常有什么异同？"><a href="#运行时的异常和一般异常有什么异同？" class="headerlink" title="运行时的异常和一般异常有什么异同？"></a>运行时的异常和一般异常有什么异同？</h2><p>  运行时异常: 可以编译通过,运行时报错<br>  一般异常:  编译时报警告,需提供处理异常方式</p>
<h2 id="try-catch中return和finally哪个优先执行"><a href="#try-catch中return和finally哪个优先执行" class="headerlink" title="try-catch中return和finally哪个优先执行"></a>try-catch中return和finally哪个优先执行</h2><p>  finally会优先执行，在一段代码中，finally是必须执行的</p>
<h2 id="请说出常见的运行异常"><a href="#请说出常见的运行异常" class="headerlink" title="请说出常见的运行异常"></a>请说出常见的运行异常</h2><p>  空指针,数组溢出,类型转换,算术异常</p>
<h2 id="有用过NIO吗？NIO的优点在哪里？"><a href="#有用过NIO吗？NIO的优点在哪里？" class="headerlink" title="有用过NIO吗？NIO的优点在哪里？"></a>有用过NIO吗？NIO的优点在哪里？</h2><p>  NIO底层采用的是内存映射实现的，因此效率会比普通的IO效率要高。</p>
<h2 id="NIO是什么他跟IO有什么区别？"><a href="#NIO是什么他跟IO有什么区别？" class="headerlink" title="NIO是什么他跟IO有什么区别？"></a>NIO是什么他跟IO有什么区别？</h2><ul>
<li>NIO是NO Block IO流,是一种基于通道与缓冲区操作的流,是非阻塞的流,读写效率高</li>
<li>IO是Block IO流,是一种基于读写操作的流,是阻塞流,读写效率比NIO低</li>
</ul>
<h1 id="多线程-网络编程"><a href="#多线程-网络编程" class="headerlink" title="多线程,网络编程"></a>多线程,网络编程</h1><h2 id="线程池有没有用过，怎么用的，在哪里用的？"><a href="#线程池有没有用过，怎么用的，在哪里用的？" class="headerlink" title="线程池有没有用过，怎么用的，在哪里用的？"></a>线程池有没有用过，怎么用的，在哪里用的？</h2><p>  在需要创建和销毁大量临时线程时,可以使用线程池</p>
<h2 id="SimpleDataFormat是线程安全的吗？"><a href="#SimpleDataFormat是线程安全的吗？" class="headerlink" title="SimpleDataFormat是线程安全的吗？"></a>SimpleDataFormat是线程安全的吗？</h2><p>  不是    </p>
<h2 id="启动一个线程用的是start-还是run"><a href="#启动一个线程用的是start-还是run" class="headerlink" title="启动一个线程用的是start()还是run()?"></a>启动一个线程用的是start()还是run()?</h2><p>  启动线程应该采用start()方法。如果直接调用run()方法，则会像调用普通方法一样执行run方法中的内容。就不会有争抢cpu时间片的过程，达不到线程的效果。</p>
<h2 id="sleep-和wait-有什么区别？"><a href="#sleep-和wait-有什么区别？" class="headerlink" title="sleep()和wait()有什么区别？"></a>sleep()和wait()有什么区别？</h2><ul>
<li>sleep()方法：<br>sleep()方法是Thread类中的静态方法，当一个线程调用sleep()方法以后，不会释放同步资源锁，其他线程仍然会等待资源锁的释放。</li>
<li>wait()方法：<br>wait()方法是Object类提供的一个普通方法，而且必须同同步资源锁对象在同步代码块或者同步方法中调用。当调用wait()方法后，当前线程会立刻释放掉同步锁资源。其他线程就有机会获得同步资源锁从而继续往下执行。</li>
</ul>
<h2 id="谈谈创建多线程的方式"><a href="#谈谈创建多线程的方式" class="headerlink" title="谈谈创建多线程的方式"></a>谈谈创建多线程的方式</h2><ul>
<li>继承Thread的方式<br>使用这种方式，当前类就代表一个线程类。可以直接调用start方法启动线程。在线程执行体中要获取当前正在执行的线程只需要通过this关键字就可以了。缺点在于Java的单继承特性，一旦当前类继承了Thread类就没有办法再继承其他类了。</li>
<li>实现Runnable接口的方式<br>使用这种方式，当前类并不代表线程。只是代表线程的一个执行体。想要启动线程还必须new一个Thread对象，将执行体对象传过去执行。好处在于Runnable是一个接口，并不耽误继承其他类。缺点在于稍显麻烦，获取当前正在执行的线程不能用this关键字，应该采用 Thread.currentThread();方式。</li>
<li>使用Callable和Future创建线程<br>这种方式创建的线程好处在于，可以有返回值</li>
</ul>
<h2 id="谈谈你对线程安全的理解？如何解决线程的安全问题？"><a href="#谈谈你对线程安全的理解？如何解决线程的安全问题？" class="headerlink" title="谈谈你对线程安全的理解？如何解决线程的安全问题？"></a>谈谈你对线程安全的理解？如何解决线程的安全问题？</h2><ul>
<li>当多个线程互抢资源时,会造成数据混乱;通过线程安全可以确保数据完整性;</li>
<li>线程的安全可以通过以下加锁方式解决:<ol>
<li>同步代码块</li>
<li>同步方法</li>
<li>互斥对象锁</li>
</ol>
</li>
</ul>
<h2 id="Synchronized加在普通方法和静态方法的区别"><a href="#Synchronized加在普通方法和静态方法的区别" class="headerlink" title="Synchronized加在普通方法和静态方法的区别"></a>Synchronized加在普通方法和静态方法的区别</h2><ul>
<li>Synchronized修饰普通方法:要确保调用该方法的对象为同一对象,才能确保线程安全</li>
<li>Synchronized修饰静态方法:静态方法属于类,可以确保线程安全</li>
</ul>
<h2 id="同步代码块和同步方法的区别"><a href="#同步代码块和同步方法的区别" class="headerlink" title="同步代码块和同步方法的区别"></a>同步代码块和同步方法的区别</h2><ul>
<li>同步代码块锁的范围是代码块区域</li>
<li>同步方法锁的范围是当前的方法块区域    </li>
</ul>
<h2 id="谈谈线程的生命周期"><a href="#谈谈线程的生命周期" class="headerlink" title="谈谈线程的生命周期"></a>谈谈线程的生命周期</h2><ol>
<li>实例化线程对象</li>
<li>启动线程</li>
<li>进入就绪状态</li>
<li>cpu调度后进入运行状态</li>
<li>当cpu调度另一线程或当前线程进入阻塞后重新回到3,就绪状态 </li>
<li>线程的结束</li>
</ol>
<h2 id="谈谈对线程池的理解？jdk提供了哪几种线程池？他们有什么区别？"><a href="#谈谈对线程池的理解？jdk提供了哪几种线程池？他们有什么区别？" class="headerlink" title="谈谈对线程池的理解？jdk提供了哪几种线程池？他们有什么区别？"></a>谈谈对线程池的理解？jdk提供了哪几种线程池？他们有什么区别？</h2><ul>
<li>线程池可以提高线程的创建和销毁的开销</li>
<li>jdk提供了以下几种线程池:<ol>
<li>newSingleThreadExecutor(单线程的线程池)<br>只有一个线程在执行,相对于单线程执行任务</li>
<li>newFixedThreadPool(固定大小的线程池)<br>固定线程数处理任务;当任务过多,则固定的线程数谁先执行完任务,就执行剩余任务</li>
<li>newScheduledThreadPool(可缓存的线程池)<br>如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</li>
</ol>
</li>
</ul>
<h2 id="对多线程的了解？在什么地方使用到过多线程？是否有用过线程池？用的什么线程池？"><a href="#对多线程的了解？在什么地方使用到过多线程？是否有用过线程池？用的什么线程池？" class="headerlink" title="对多线程的了解？在什么地方使用到过多线程？是否有用过线程池？用的什么线程池？"></a>对多线程的了解？在什么地方使用到过多线程？是否有用过线程池？用的什么线程池？</h2><p>  多线程是程序中的多条执行路径,每个线程在程序中互抢资源;在购票系统,通讯聊天中可以用到多线程<br>  newCachedThreadPool:带缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</p>
<h2 id="UDP和TCP的区别"><a href="#UDP和TCP的区别" class="headerlink" title="UDP和TCP的区别"></a>UDP和TCP的区别</h2><ul>
<li>UDP:无连接的传输协议,数据不安全,性能高</li>
<li>TCP:建立连接的传输协议,数据安全,性能低</li>
</ul>
<h2 id="网络的分层"><a href="#网络的分层" class="headerlink" title="网络的分层"></a>网络的分层</h2><p>  OSI七层模型: 应用程,表示层,会话层,传输层,网络层,数据链路层,物理层<br>  TCP四层模型: 应用层,传输层,网络层,网络接口层</p>
<h2 id="什么是tcp协议"><a href="#什么是tcp协议" class="headerlink" title="什么是tcp协议"></a>什么是tcp协议</h2><p>  是一种可靠安全的传输协议,传输效率低,需建立连接,经过三次握手;</p>
<h2 id="Http和Https的区别"><a href="#Http和Https的区别" class="headerlink" title="Http和Https的区别"></a>Http和Https的区别</h2><ul>
<li>http: 超文本传输协议,是一种明文的传输协议</li>
<li>https: 可理解为安全版的超文本传输,进行加密的一种传输协议</li>
</ul>
<h2 id="Http的报文里有什么"><a href="#Http的报文里有什么" class="headerlink" title="Http的报文里有什么"></a>Http的报文里有什么</h2><p>  报文里有: 请求行（requestline）、请求头部（header）、空行和请求数据等4个部分组成</p>
<h1 id="反射与解析"><a href="#反射与解析" class="headerlink" title="反射与解析"></a>反射与解析</h1><h2 id="解析XML有几种方式"><a href="#解析XML有几种方式" class="headerlink" title="解析XML有几种方式"></a>解析XML有几种方式</h2><p>  dom解析,sax解析,pull解析</p>
<h2 id="反射你是怎么理解的？"><a href="#反射你是怎么理解的？" class="headerlink" title="反射你是怎么理解的？"></a>反射你是怎么理解的？</h2><ul>
<li>通过方式机制可以获取私有的属性,方法,构造器</li>
<li><p>在应用上更灵活性,例如在文件注入方面的使用,通过加载类名,可以得到所属对象的信息</p>
</li>
<li><p>平常用什么工具解析json？xml转换成json字符串展示出来是什么样子的？</p>
</li>
<li>解析json的工具有: json-lib,Gson,Fast-json</li>
<li>xml解析为json: 标签形式转为: {key1:value1,key2:value2}</li>
</ul>
<h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><h2 id="请写出下面代码的运行结果"><a href="#请写出下面代码的运行结果" class="headerlink" title="请写出下面代码的运行结果"></a>请写出下面代码的运行结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s =”123”;</span><br><span class="line">String temp=s;</span><br><span class="line">temp=”1234”;</span><br><span class="line">System.out.println(s);</span><br><span class="line">System.out.println(temp);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>打印结果: 123<br>         1234</p>
</blockquote>
<h2 id="给定一个不重复的自然数数组｛3，5，9，7，4，13，15，0，2，20｝，已知其最大值20，请将其按从小到大的方式顺序输出，要求算法复杂度为1"><a href="#给定一个不重复的自然数数组｛3，5，9，7，4，13，15，0，2，20｝，已知其最大值20，请将其按从小到大的方式顺序输出，要求算法复杂度为1" class="headerlink" title="给定一个不重复的自然数数组｛3，5，9，7，4，13，15，0，2，20｝，已知其最大值20，请将其按从小到大的方式顺序输出，要求算法复杂度为1"></a>给定一个不重复的自然数数组｛3，5，9，7，4，13，15，0，2，20｝，已知其最大值20，请将其按从小到大的方式顺序输出，要求算法复杂度为1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		//一个不重复的自然数数组</span><br><span class="line">		int[] array = &#123;3,5,9,7,4,13,15,0,2,20&#125;;</span><br><span class="line">		//最大值为20</span><br><span class="line">		int max = 20;</span><br><span class="line">		</span><br><span class="line">		//首先创建一个长度为 最大值+1 的新Integer（消除0的默认值）数据</span><br><span class="line">		Integer[] newarray = new Integer[max + 1];</span><br><span class="line">		//遍历老数组，将每个元素以此插入到新元素的指定位置（规则：每个元素本身对应的下标位置）</span><br><span class="line">		for(int i = 0; i &lt; array.length; i++)&#123;</span><br><span class="line">			newarray[array[i]] = array[i];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		//遍历新数组，以此打印，遇到null则跳过</span><br><span class="line">		for(int i = 0; i &lt; newarray.length; i++)&#123;</span><br><span class="line">			if(newarray[i] != null)&#123;</span><br><span class="line">				System.out.print(newarray[i] + &quot; &quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对于1-100范围内的整数I（包括100），找出满足I，I-4，I-10（I-10也在100范围）都是素质的整数I，计算这样I的个数cnt和这些整数的和sum"><a href="#对于1-100范围内的整数I（包括100），找出满足I，I-4，I-10（I-10也在100范围）都是素质的整数I，计算这样I的个数cnt和这些整数的和sum" class="headerlink" title="对于1-100范围内的整数I（包括100），找出满足I，I+4，I+10（I+10也在100范围）都是素质的整数I，计算这样I的个数cnt和这些整数的和sum"></a>对于1-100范围内的整数I（包括100），找出满足I，I+4，I+10（I+10也在100范围）都是素质的整数I，计算这样I的个数cnt和这些整数的和sum</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//个数:7;总和:201</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		int count = 0;</span><br><span class="line">		int sum = 0;</span><br><span class="line">		for(int i=1;i&lt;=100;i++)&#123;</span><br><span class="line">			int j;</span><br><span class="line">			for(j=2;j&lt;i;j++)&#123;</span><br><span class="line">				if(i%j==0||(i+4)%j==0||(i+10)%j==0)&#123;</span><br><span class="line">					if(i+10&gt;100)&#123;</span><br><span class="line">						System.out.println(&quot;个数:&quot;+count+&quot;;总和:&quot;+sum);</span><br><span class="line">						return;</span><br><span class="line">					&#125;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(i==j&amp;&amp;i&gt;2)&#123;</span><br><span class="line">				count++;</span><br><span class="line">				sum += i;</span><br><span class="line">				System.out.println(&quot;素数:&quot;+i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用java代码找出A数组中不存在于B数组的项-例如-A-1-2-3-B-4-2"><a href="#用java代码找出A数组中不存在于B数组的项-例如-A-1-2-3-B-4-2" class="headerlink" title="用java代码找出A数组中不存在于B数组的项,例如:A[1,2,3],B[4,2]"></a>用java代码找出A数组中不存在于B数组的项,例如:A[1,2,3],B[4,2]</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		int[] a = &#123;1,2,3,9,5,7&#125;;</span><br><span class="line">		int[] b = &#123;2,4,9&#125;;</span><br><span class="line">		for(int i=0;i&lt;a.length;i++)&#123;</span><br><span class="line">			int j;</span><br><span class="line">			for(j=0;j&lt;b.length;j++)&#123;</span><br><span class="line">				if(a[i]==b[j])&#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(j==b.length)&#123;</span><br><span class="line">				System.out.print(a[i]+&quot;\t&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单例具体实现"><a href="#单例具体实现" class="headerlink" title="单例具体实现"></a>单例具体实现</h2><blockquote>
<p> 1.构造方法私有化<br> 2.调用静态方法获取对象,且每次获取的对象都相同</p>
</blockquote>
<h2 id="请在如下函数体中补充完成代码，实现根据输入字符串返回该字符串的倒序形式。如输入“ABC”返回“CBA”。"><a href="#请在如下函数体中补充完成代码，实现根据输入字符串返回该字符串的倒序形式。如输入“ABC”返回“CBA”。" class="headerlink" title="请在如下函数体中补充完成代码，实现根据输入字符串返回该字符串的倒序形式。如输入“ABC”返回“CBA”。"></a>请在如下函数体中补充完成代码，实现根据输入字符串返回该字符串的倒序形式。如输入“ABC”返回“CBA”。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Public String getReverseString(String str)&#123;</span><br><span class="line">	char[] a = str.toCharArray();  //得到字符数组</span><br><span class="line">		for(int i=0;i&lt;a.length/2;i++)&#123;  </span><br><span class="line">			char t = a[i];  //首尾交换</span><br><span class="line">			a[i] = a[a.length-1-i];</span><br><span class="line">			a[a.length-1-i] = t;</span><br><span class="line">		&#125;</span><br><span class="line">		String s = new String(a);</span><br><span class="line">		return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="下面的程序代码输出的结果是多少？"><a href="#下面的程序代码输出的结果是多少？" class="headerlink" title="下面的程序代码输出的结果是多少？"></a>下面的程序代码输出的结果是多少？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class smallT&#123;</span><br><span class="line">   public static void main(String  args[])&#123;</span><br><span class="line">      smallT  t=new smallT();</span><br><span class="line">      Int  b=t.get();</span><br><span class="line">      System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">    public int get()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            return  1;</span><br><span class="line">        &#125;</span><br><span class="line">        finally&#123;</span><br><span class="line">           return 2;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 2<br> 因为finally优先级比return高,哪怕return了,最终也要执行finally中的代码</p>
</blockquote>
<h2 id="写一个函数，2-个参数，1-个字符串，1-个字节数，返回截取的字符串，要求字符串中的中文不能出现乱码：如（“我ABC”，4）应该截为“我AB”，输入（“我ABC-汉DEF”，6）应该输出为“我ABC”而不是“我ABC-汉的半个”。"><a href="#写一个函数，2-个参数，1-个字符串，1-个字节数，返回截取的字符串，要求字符串中的中文不能出现乱码：如（“我ABC”，4）应该截为“我AB”，输入（“我ABC-汉DEF”，6）应该输出为“我ABC”而不是“我ABC-汉的半个”。" class="headerlink" title="写一个函数，2 个参数，1 个字符串，1 个字节数，返回截取的字符串，要求字符串中的中文不能出现乱码：如（“我ABC”，4）应该截为“我AB”，输入（“我ABC 汉DEF”，6）应该输出为“我ABC”而不是“我ABC+汉的半个”。"></a>写一个函数，2 个参数，1 个字符串，1 个字节数，返回截取的字符串，要求字符串中的中文不能出现乱码：如（“我ABC”，4）应该截为“我AB”，输入（“我ABC 汉DEF”，6）应该输出为“我ABC”而不是“我ABC+汉的半个”。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//方式1:</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		subString(&quot;我abc&quot;,4);</span><br><span class="line">		subString(&quot;我abc汉EF&quot;,6);</span><br><span class="line">	&#125;</span><br><span class="line">	private static void subString(String str, int len) &#123;</span><br><span class="line">		char[] b = str.toCharArray();</span><br><span class="line">		StringBuffer sb = new StringBuffer();</span><br><span class="line">		for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">			if(b[i]&gt;=0&amp;&amp;b[i]&lt;=255)&#123;</span><br><span class="line">				sb.append(b[i]);</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				if(i!=len-1)&#123;</span><br><span class="line">					sb.append(b[i]);</span><br><span class="line">				&#125;</span><br><span class="line">				len--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(sb.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">方式2:</span><br><span class="line">utf-8编码，一个汉字占3个字节，gbk编码，一个汉字占2个字节</span><br><span class="line"> 截取字符串：在gbk编码中，汉字一半的字节都是小于0的</span><br><span class="line"></span><br><span class="line">	public static String splitFirst(String str, int bytesize) throws UnsupportedEncodingException &#123;</span><br><span class="line">		byte[] buf = str.getBytes(&quot;GBK&quot;);</span><br><span class="line">		int num = 0;</span><br><span class="line">		boolean bChineseFirstHalf = false;</span><br><span class="line">		for (int i = 0; i &lt; bytesize; i++) &#123;</span><br><span class="line">			if (buf[i] &lt; 0 &amp;&amp; !bChineseFirstHalf) &#123;</span><br><span class="line">				bChineseFirstHalf = true;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				num++;</span><br><span class="line">				bChineseFirstHalf = false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return str.substring(0, num);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="给定的一个文件“a-txt”-找出所有符合“Japanes”字符串的个数，并修改为“Japanese”"><a href="#给定的一个文件“a-txt”-找出所有符合“Japanes”字符串的个数，并修改为“Japanese”" class="headerlink" title="给定的一个文件“a.txt”,找出所有符合“Japanes”字符串的个数，并修改为“Japanese”"></a>给定的一个文件“a.txt”,找出所有符合“Japanes”字符串的个数，并修改为“Japanese”</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;a.txt&quot;));</span><br><span class="line">		StringBuffer sb = new StringBuffer();</span><br><span class="line">		String msg;</span><br><span class="line">		while((msg=br.readLine())!=null)&#123;</span><br><span class="line">			sb.append(msg);</span><br><span class="line">		&#125;</span><br><span class="line">		msg = sb.toString();</span><br><span class="line">		br.close();</span><br><span class="line">		int count = 0;</span><br><span class="line">		int index = msg.indexOf(&quot;Japanese&quot;);</span><br><span class="line">		while(index&gt;=0)&#123;</span><br><span class="line">			count++;</span><br><span class="line">			msg = msg.substring(index+1);</span><br><span class="line">			index = msg.indexOf(&quot;Japanese&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;匹配的个数为:&quot;+count);</span><br><span class="line">		BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;a.txt&quot;));</span><br><span class="line">		msg = sb.toString();</span><br><span class="line">		msg = msg.replace(&quot;Japanese&quot;, &quot;Japanese&quot;);</span><br><span class="line">		bw.write(msg);</span><br><span class="line">		bw.close();</span><br></pre></td></tr></table></figure>
<h1 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h1><ul>
<li><p>现在有一个工人帮你干7天的活，你需要每天付给他等额的工钱，现在你有一块宝石，这个宝石只能切割两次，如何给他付工钱？</p>
</li>
<li><p>有一个教授，在他三个弟子头上分别贴上了3个正整数，其中2个数相加等于第三个数（能看到别人看不见自己的），教授问第一个弟子你知道自己头上的是什么数么，第一个弟子说不知道，教授又问第二个弟子，第二个弟子也说不知道，这时第三个弟子说我知道了，自己头上是144，请问为什么第三个弟子那么肯定自己头上是144？另外两个弟子头上是什么数字？</p>
</li>
<li><p>在某一沙漠边，两位考古工作者想穿过这篇沙漠到另一边的小镇去考古，这片沙漠虽不大，要穿过它也需要10天时间。但是，没每人随身只能带8斤粮食和8斤水。而每人每天起码要消耗1斤粮食和1斤水。由于当地又没有骆驼可以租用，使他们在旅途中因为无法得到粮食和水的补充而不能完全抵达到沙漠另一边。当然，当地的民工是有的，但他们每人也只能带8斤粮食和8斤水，而且他们每天也要消耗1斤粮食和1斤水。考古工作者该怎样穿过这片沙漠？</p>
</li>
<li><p>猜牌问题S先生、P先生、Q先生他们知道桌子的抽屉里有16张扑克牌：红桃A、Q、4黑桃J、8、4、2、7、3草花K、Q、5、4、6方块A、5。约翰教授从这16张牌中挑出一张牌来，并把这张牌的点数告诉P先生，把这张牌的花色告诉Q先生。这时，约翰教授问P先生和Q先生：你们能从已知的点数或花色中推知这张牌是什么牌吗？于是，S先生听到如下的对话：P先生：我不知道这张牌。Q先生：我知道你不知道这张牌。P先生：现在我知道这张牌了。Q先生：我也知道了。听罢以上的对话，S先生想了一想之后，就正确地推出这张牌是什么牌。请问：这张牌是什么牌？</p>
</li>
<li><p>烧一根不均匀的绳要用一个小时，如何用它来判断半个小时？烧一根不均匀的绳,从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子,问如何用烧绳的方法来计时一个小时十五分钟呢?</p>
</li>
</ul>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2018/11/30/JavaEE第一阶段面试题总结（持续更新）/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2018/11/30/JavaEE第一阶段面试题总结（持续更新）/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
